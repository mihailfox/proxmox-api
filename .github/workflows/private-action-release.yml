name: private-action-release

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Release tag (e.g., v0.1.0)'
        required: false
      release-items:
        description: 'Task or issue IDs to include in release notes (comma or semicolon separated)'
        required: false
  push:
    branches:
      - main
    paths:
      - '.github/actions/proxmox-openapi-artifacts/**'
      - 'tools/automation/**'
      
jobs:
  validate:
    name: Validate action tooling
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 24
          cache: npm
          cache-dependency-path: package-lock.json
      - name: Install dependencies
        run: npm ci
      - name: Lint
        run: npm run lint
      - name: TypeScript build
        run: npm run build
      - name: Smoke automation pipeline
        run: npm run automation:pipeline -- --mode=ci --report tmp/action-summary.json
      - name: Prepare action workspace
        run: |
          set -euo pipefail
          npm run action:install
          npm run action:package
  release_guard:
    name: Evaluate release trigger
    runs-on: ubuntu-latest
    outputs:
      should_release: ${{ steps.decision.outputs.should_release }}
      pve_version: ${{ steps.metadata.outputs.version }}
      pve_updated_at: ${{ steps.metadata.outputs.updated_at }}
      pve_metadata: ${{ steps.metadata.outputs.metadata }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Discover Proxmox docs metadata
        id: metadata
        run: |
          set -euo pipefail
          python tools/scripts/fetch_pve_docs_metadata.py --output pve-metadata.json
          cat pve-metadata.json
          VERSION="$(jq -r '.version // empty' pve-metadata.json)"
          UPDATED="$(jq -r '.updated_at // empty' pve-metadata.json)"
          ERROR_MESSAGE="$(jq -r '.error // empty' pve-metadata.json)"
          if [ -z "$VERSION" ]; then
            VERSION="unknown"
          fi
          if [ -z "$UPDATED" ]; then
            UPDATED="unknown"
          fi
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "updated_at=$UPDATED" >> "$GITHUB_OUTPUT"
          echo "metadata=$(jq -c '.' pve-metadata.json)" >> "$GITHUB_OUTPUT"
          {
            echo "## Proxmox docs metadata"
            echo "- Version: $VERSION"
            echo "- Last updated: $UPDATED"
            if [ -n "$ERROR_MESSAGE" ]; then
              echo "- Fetch error: $ERROR_MESSAGE"
            fi
          } >> "$GITHUB_STEP_SUMMARY"
      - name: Evaluate release guard
        id: decision
        run: |
          set -euo pipefail
          SHOULD_RELEASE="true"
          EVENT_NAME="$GITHUB_EVENT_NAME"
          PVE_VERSION="${{ steps.metadata.outputs.version }}"
          if [ "$PVE_VERSION" = "" ] || [ "$PVE_VERSION" = "unknown" ]; then
            PVE_VERSION=""
          fi
          if [ "$EVENT_NAME" = "push" ] && [ -n "$PVE_VERSION" ]; then
            git fetch --tags --force >/dev/null 2>&1 || true
            if git tag --list "schema-*-pve-$PVE_VERSION" | grep -q .; then
              SHOULD_RELEASE="false"
              {
                echo "## Release guard"
                echo "- Skipping release: schema tag for PVE version $PVE_VERSION already exists."
              } >> "$GITHUB_STEP_SUMMARY"
            fi
          fi
          if [ "$SHOULD_RELEASE" = "true" ]; then
            {
              echo "## Release guard"
              echo "- Proceeding with release automation."
            } >> "$GITHUB_STEP_SUMMARY"
          fi
          echo "should_release=$SHOULD_RELEASE" >> "$GITHUB_OUTPUT"
  release_action:
    name: Publish action release
    needs:
      - validate
      - release_guard
    if: ${{ needs.validate.result == 'success' && needs.release_guard.outputs.should_release == 'true' }}
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      action_tag: ${{ steps.metadata.outputs.action_tag }}
      release_version: ${{ steps.metadata.outputs.release_version }}
      is_prerelease: ${{ steps.metadata.outputs.is_prerelease }}
      previous_tag: ${{ steps.metadata.outputs.previous_tag }}
      release_items: ${{ steps.metadata.outputs.release_items }}
      release_notes_b64: ${{ steps.compose.outputs.notes_b64 }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 24
          cache: npm
          cache-dependency-path: package-lock.json
      - name: Install dependencies
        run: npm install
      - name: Gather release inputs
        id: metadata
        run: |
          set -euo pipefail
          EVENT_NAME="$GITHUB_EVENT_NAME"
          REQUESTED_VERSION=""
          RELEASE_ITEMS=""
          SOURCE_MODE="automatic"
          if [ "$EVENT_NAME" = "workflow_dispatch" ]; then
            REQUESTED_VERSION="$(jq -r '.inputs.version // ""' "$GITHUB_EVENT_PATH")"
            RELEASE_ITEMS="$(jq -r '.inputs["release-items"] // ""' "$GITHUB_EVENT_PATH")"
            SOURCE_MODE="manual"
          fi

          normalize_version() {
            local raw="$1"
            if [[ "$raw" =~ ^v[0-9]+\.[0-9]+\.[0-9A-Za-z.+-]+$ ]]; then
              echo "$raw"
              return 0
            fi
            echo "Error: version '$raw' must start with 'v' and follow semantic versioning (e.g., v0.3.1)." >&2
            return 1
          }

          LAST_TAG="$(git tag --list 'v[0-9]*.[0-9]*.[0-9A-Za-z.+-]*' --sort=-version:refname | head -n1)"

          if [ -n "$REQUESTED_VERSION" ]; then
            RELEASE_VERSION="$(normalize_version "$REQUESTED_VERSION")"
            ACTION_TAG="$RELEASE_VERSION"
          else
            if [ -z "$LAST_TAG" ]; then
              RELEASE_VERSION="v0.1.0"
            else
              RELEASE_VERSION="$(python tools/scripts/compute_next_version.py --last-tag "$LAST_TAG")"
            fi
            ACTION_TAG="$RELEASE_VERSION"
          fi

          if git rev-parse "$ACTION_TAG" >/dev/null 2>&1; then
            echo "Release tag '$ACTION_TAG' already exists. Specify a new version." >&2
            exit 1
          fi

          if [[ "$ACTION_TAG" == *-* ]]; then
            IS_PRERELEASE="true"
          else
            IS_PRERELEASE="false"
          fi

          echo "action_tag=$ACTION_TAG" >> "$GITHUB_OUTPUT"
          echo "release_version=$ACTION_TAG" >> "$GITHUB_OUTPUT"
          echo "is_prerelease=$IS_PRERELEASE" >> "$GITHUB_OUTPUT"
          echo "previous_tag=$LAST_TAG" >> "$GITHUB_OUTPUT"
          echo "release_items=$RELEASE_ITEMS" >> "$GITHUB_OUTPUT"

          {
            echo "## Release metadata"
            echo "- Selected tag: $ACTION_TAG"
            if [ -n "$LAST_TAG" ]; then
              echo "- Previous stable tag: $LAST_TAG"
            fi
            echo "- Mode: $SOURCE_MODE"
            echo "- Prerelease: $IS_PRERELEASE"
            if [ -n "$RELEASE_ITEMS" ]; then
              echo "- Release items: $RELEASE_ITEMS"
            fi
          } >> "$GITHUB_STEP_SUMMARY"
      - name: Compose release notes
        id: compose
        env:
          RELEASE_ITEMS: ${{ steps.metadata.outputs.release_items }}
          PREVIOUS_TAG: ${{ steps.metadata.outputs.previous_tag }}
        run: |
          set -euo pipefail
          ARGS=("--output=var/reports/release-notes.md")
          if [ -n "$RELEASE_ITEMS" ]; then
            ARGS+=("--items=$RELEASE_ITEMS")
          fi
          if [ -n "$PREVIOUS_TAG" ]; then
            ARGS+=("--base-ref=$PREVIOUS_TAG")
          fi
          npx tsx tools/scripts/compose-release-notes.ts "${ARGS[@]}"
          python tools/scripts/base64_encode_file.py \
            --input var/reports/release-notes.md \
            --key notes_b64 \
            --output "$GITHUB_OUTPUT"
      - name: Build action bundle
        run: |
          set -euo pipefail
          npm install
          npm run action:package
      - name: Package action directory
        run: |
          set -euo pipefail
          rm -rf tmp/action-release proxmox-openapi-action.zip
          mkdir -p tmp/action-release
          cp .github/actions/proxmox-openapi-artifacts/action.yml tmp/action-release/
          cp .github/actions/proxmox-openapi-artifacts/package.json tmp/action-release/
          cp .github/actions/proxmox-openapi-artifacts/package-lock.json tmp/action-release/
          cp -R .github/actions/proxmox-openapi-artifacts/dist tmp/action-release/
          (cd tmp/action-release && zip -r ../../proxmox-openapi-action.zip .)
      - name: Smoke test action bundle
        run: |
          set -euo pipefail
          rm -rf tmp/action-smoke
          mkdir -p tmp/action-smoke tmp/action-work
          unzip -q proxmox-openapi-action.zip -d tmp/action-smoke
          ACTION_DIR="$(realpath tmp/action-smoke)"
          export GITHUB_ACTION_PATH="$ACTION_DIR"
          export GITHUB_WORKSPACE="$(pwd)"
          export RUNNER_TEMP="$(pwd)/tmp/action-work"
          export RUNNER_TOOL_CACHE="$(pwd)/tmp/action-tools"
          export GITHUB_OUTPUT="$RUNNER_TEMP/output"
          export GITHUB_STEP_SUMMARY="$RUNNER_TEMP/summary"
          export INPUT_MODE=ci
          export INPUT_OFFLINE=true
          export INPUT_FALLBACK_TO_CACHE=true
          export INPUT_INSTALL_COMMAND=
          export INPUT_INSTALL_PLAYWRIGHT_BROWSERS=false
          export INPUT_WORKING_DIRECTORY=.
          export INPUT_REPORT_PATH="$RUNNER_TEMP/summary.json"
          mkdir -p "$RUNNER_TEMP" "$RUNNER_TOOL_CACHE"
          node "$ACTION_DIR/dist/index.js"
      - name: Create action release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          TAG="${{ steps.metadata.outputs.action_tag }}"
          PRERELEASE="${{ steps.metadata.outputs.is_prerelease }}"
          NOTES_FILE="var/reports/release-notes.md"
          if [ ! -s "$NOTES_FILE" ]; then
            echo "Release notes file not found at $NOTES_FILE" >&2
            exit 1
          fi
          ARGS=(
            "$TAG"
            "proxmox-openapi-action.zip"
            "--notes-file"
            "$NOTES_FILE"
          )
          if [ "$PRERELEASE" = "true" ]; then
            ARGS+=("--prerelease")
          fi
          gh release create "${ARGS[@]}"

  release_schema:
    name: Publish Proxmox API schema
    needs:
      - validate
      - release_action
      - release_guard
    if: ${{ needs.release_action.result == 'success' }}
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 24
          cache: npm
          cache-dependency-path: package-lock.json
      - name: Install dependencies
        run: npm ci
      - name: Generate OpenAPI artifacts
        run: npm run automation:pipeline -- --mode=ci --report var/automation-summary.json
      - name: Prepare Proxmox docs metadata
        id: pve
        env:
          PVE_METADATA: ${{ needs.release_guard.outputs.pve_metadata }}
        run: |
          set -euo pipefail
          if [ -n "$PVE_METADATA" ] && [ "$PVE_METADATA" != "null" ]; then
            printf '%s' "$PVE_METADATA" | jq . > pve-metadata.json
          else
            python tools/scripts/fetch_pve_docs_metadata.py --output pve-metadata.json
          fi
          cat pve-metadata.json
          VERSION="$(jq -r '.version // empty' pve-metadata.json)"
          UPDATED="$(jq -r '.updated_at // empty' pve-metadata.json)"
          ERROR_MESSAGE="$(jq -r '.error // empty' pve-metadata.json)"
          if [ -z "$VERSION" ]; then
            VERSION="unknown"
          fi
          if [ -z "$UPDATED" ]; then
            UPDATED="unknown"
          fi
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "updated_at=$UPDATED" >> "$GITHUB_OUTPUT"
          {
            echo "## Proxmox docs metadata"
            echo "- Version: $VERSION"
            echo "- Last updated: $UPDATED"
            if [ -n "$ERROR_MESSAGE" ]; then
              echo "- Fetch error: $ERROR_MESSAGE"
            fi
          } >> "$GITHUB_STEP_SUMMARY"
      - name: Package schema artifacts
        run: |
          set -euo pipefail
          rm -f proxmox-openapi-schema.zip
          zip -j proxmox-openapi-schema.zip \
            var/openapi/proxmox-ve.json \
            var/openapi/proxmox-ve.yaml
      - name: Restore release notes
        env:
          NOTES_B64: ${{ needs.release_action.outputs.release_notes_b64 }}
        run: |
          set -euo pipefail
          if [ -z "$NOTES_B64" ]; then
            echo "Missing release notes from action job." >&2
            exit 1
          fi
          python tools/scripts/base64_decode_to_file.py \
            --env NOTES_B64 \
            --output var/reports/release-notes.md
      - name: Create schema release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          RELEASE_VERSION: ${{ needs.release_action.outputs.release_version }}
          PRERELEASE: ${{ needs.release_action.outputs.is_prerelease }}
          PVE_VERSION: ${{ steps.pve.outputs.version }}
          PVE_UPDATED_AT: ${{ steps.pve.outputs.updated_at }}
        run: |
          set -euo pipefail
          if [ -z "$RELEASE_VERSION" ]; then
            echo "Missing release version from action job." >&2
            exit 1
          fi
          SCHEMA_TAG="schema-$RELEASE_VERSION"
          if [ -n "$PVE_VERSION" ] && [ "$PVE_VERSION" != "unknown" ]; then
            SCHEMA_TAG+="-pve-$PVE_VERSION"
          fi
          ARGS=(
            "$SCHEMA_TAG"
            "proxmox-openapi-schema.zip"
            "pve-metadata.json"
            "--notes-file"
            "var/reports/release-notes.md"
          )
          if [ "$PRERELEASE" = "true" ]; then
            ARGS+=("--prerelease")
          fi
          gh release create "${ARGS[@]}"
